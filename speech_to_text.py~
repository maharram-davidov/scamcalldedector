# Hybrid Scam Detection with Real-Time Voice Input and Gemini Trigger (Improved Risk Logic)

import os
import threading
import azure.cognitiveservices.speech as speechsdk
from azure.ai.textanalytics import (
    AnalyzeSentimentAction,
    RecognizeEntitiesAction,
    ExtractKeyPhrasesAction,
    TextAnalyticsClient
)
from azure.core.credentials import AzureKeyCredential
from dotenv import load_dotenv
from datetime import datetime
import google.generativeai as genai
import re

# Load environment variables
load_dotenv()

# Configure Gemini AI
genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
model = genai.GenerativeModel('gemini-2.0-flash')

SCAM_PATTERNS = {
    'urgency': [r't…ôcili', r'd…ôrhal', r'indi', r'bu g√ºn', r'bu saat', r'tez', r'c…ôld'],
    'money': [r'pul', r'√∂d…ôni≈ü', r'kart', r'bank', r'kredit', r'borc', r'qaytarmaq', r'transfer', r'hesab'],
    'threat': [r'h…ôbs', r'c…ôza', r'qanun', r'polis', r'm…ôhk…ôm…ô', r'≈üikay…ôt', r'problem', r't…ôhl√ºk…ô'],
    'personal': [r'≈ü…ôxsi m…ôlumat', r'≈üifr…ô', r'pin', r'kart n√∂mr…ôsi', r'hesab n√∂mr…ôsi', r'≈ü…ôxsiyy…ôt']
}

class ScamAnalyzer:
    def __init__(self):
        self.text_analytics_client = TextAnalyticsClient(
            endpoint=os.getenv("AZURE_LANGUAGE_ENDPOINT"),
            credential=AzureKeyCredential(os.getenv("AZURE_LANGUAGE_KEY"))
        )
        self.conversation_history = []
        self.scam_score = 0
        self.conversation_start_time = datetime.now()
        self.suspicious_entities = set()
        self.risk_factors = {k: 0 for k in [
            'urgency_level', 'threat_level', 'personal_info_request', 'financial_request', 'emotional_manipulation']}

    def analyze_text(self, text, force_gemini=False):
        self.conversation_history.append({'text': text, 'timestamp': datetime.now()})
        documents = [text]

        try:
            pattern_matches = self._check_patterns(text)
            lang = self.text_analytics_client.detect_language(documents=documents)[0]
            poller = self.text_analytics_client.begin_analyze_actions(
                documents=documents,
                actions=[AnalyzeSentimentAction(), RecognizeEntitiesAction(), ExtractKeyPhrasesAction()],
                show_stats=False
            )

            sentiment_result, entities_result, key_phrases_result = None, None, None
            for action in poller.result():
                for result in action:
                    if result.is_error:
                        continue
                    if result.kind == "SentimentAnalysis":
                        sentiment_result = result
                    elif result.kind == "EntityRecognition":
                        entities_result = result
                    elif result.kind == "KeyPhraseExtraction":
                        key_phrases_result = result

            if not all([sentiment_result, entities_result, key_phrases_result]):
                print("‚ùå Missing Azure analysis results")
                return None

            context = self._analyze_context(text, entities_result, key_phrases_result)
            gemini_analysis = None

            self._calculate_risk_factors(sentiment_result, pattern_matches, context, None, key_phrases_result, text)
            scam_score = self._calculate_scam_score()
            self.scam_score = scam_score

            if force_gemini or scam_score >= 0.5:
                def run_gemini():
                    analysis = self._get_gemini_analysis(text, context)
                    print("\nü§ñ Gemini AI Analysis:")
                    print(analysis)
                threading.Thread(target=run_gemini).start()

            return {
                'text': text,
                'scam_score': scam_score,
                'risk_factors': self.risk_factors,
                'context': context
            }

        except Exception as e:
            print(f"‚ùå Exception in analyze_text: {e}")
            return None

    def _check_patterns(self, text):
        matches = {}
        for cat, patterns in SCAM_PATTERNS.items():
            matches[cat] = [p for p in patterns if re.search(p, text.lower())]
        return matches

    def _analyze_context(self, text, entities, key_phrases):
        context = {'suspicious_entities': [], 'time_pressure': False, 'authority_claim': False}
        for ent in entities.entities:
            if ent.category in ['Person', 'Organization', 'PhoneNumber']:
                self.suspicious_entities.add(ent.text)
                context['suspicious_entities'].append(ent.text)
        for phrase in key_phrases.key_phrases:
            if any(w in phrase.lower() for w in ['t…ôcili', 'd…ôrhal', 'tez']):
                context['time_pressure'] = True
            if any(w in phrase.lower() for w in ['polis', 'bank', 'm…ôhk…ôm…ô']):
                context['authority_claim'] = True
        return context

    def _calculate_risk_factors(self, sentiment, patterns, context, gemini, key_phrases, text):
        self.risk_factors = {k: 0 for k in self.risk_factors}
        text_lower = text.lower()

        if context['time_pressure']:
            self.risk_factors['urgency_level'] = 0.8
        if patterns['threat']:
            self.risk_factors['threat_level'] = 0.9
        if patterns['personal']:
            self.risk_factors['personal_info_request'] = 0.9
        if patterns['money']:
            self.risk_factors['financial_request'] = 0.9
        if sentiment.sentiment == 'negative':
            self.risk_factors['emotional_manipulation'] = 0.7
            if sentiment.confidence_scores.negative > 0.8:
                self.risk_factors['emotional_manipulation'] = 0.9

        # ‚úÖ Minimum baza riski …ôlav…ô et
        if self.risk_factors['personal_info_request'] > 0 or self.risk_factors['financial_request'] > 0:
            self.risk_factors['personal_info_request'] = max(self.risk_factors['personal_info_request'], 0.5)
            self.risk_factors['financial_request'] = max(self.risk_factors['financial_request'], 0.5)

        # ‚úÖ ∆èlav…ô g√ºcl…ôndirilmi≈ü riskl…ôr
        if re.search(r'≈üifr…ô|pin|cvv|son istifad…ô tarixi|kart n√∂mr…ôsi', text_lower):
            self.risk_factors['personal_info_request'] = max(self.risk_factors['personal_info_request'], 0.9)

        if re.search(r'kapital bank|pa≈üa bank|bank respublika|leobank', text_lower):
            self.risk_factors['financial_request'] = max(self.risk_factors['financial_request'], 0.9)

        if 'kart' in text_lower and 'g√∂nd…ôrin' in text_lower:
            self.risk_factors['personal_info_request'] = max(self.risk_factors['personal_info_request'], 0.9)
            self.risk_factors['financial_request'] = max(self.risk_factors['financial_request'], 0.9)

    def _calculate_scam_score(self):
        weights = {
            'urgency_level': 0.25,
            'threat_level': 0.25,
            'personal_info_request': 0.2,
            'financial_request': 0.2,
            'emotional_manipulation': 0.1
        }

        # Kvadrat artƒ±rƒ±lmƒ±≈ü risk d…ôy…ôrl…ôri il…ô baza skor
        base_score = sum((v ** 2) * weights[k] for k, v in self.risk_factors.items())

        # Konversasiya qƒ±sa olduqda daha riskli say
        duration = (datetime.now() - self.conversation_start_time).total_seconds()
        time_factor = 1.2 if duration < 30 else 1.1 if duration < 60 else 1.0

        # ≈û√ºbh…ôli varlƒ±qlar varsa artƒ±m
        entity_factor = 1.0 + (len(self.suspicious_entities) * 0.1)

        # ∆èlav…ô qoruyucu g√ºcl…ôndirm…ô:
        # ∆èg…ôr h…ôm personal, h…ôm d…ô financial request ‚â• 0.5 is…ô, bu artƒ±q scam niyy…ôti g√∂st…ôricisidir
        risk_combined = self.risk_factors['personal_info_request'] + self.risk_factors['financial_request']
        if risk_combined >= 1.5:
            combined_boost = 1.5  # ciddi risk varsa daha da g√ºcl…ôndir
        elif risk_combined >= 1.0:
            combined_boost = 1.2
        else:
            combined_boost = 1.0

        final_score = base_score * time_factor * entity_factor * combined_boost

        return min(final_score, 1.0)

    def _get_gemini_analysis(self, text, context):
        convo = "\n".join(f"{e['timestamp'].strftime('%H:%M:%S')}: {e['text']}" for e in self.conversation_history[-5:])
        prompt = f"""
        Z…ông konversasiyasƒ±nƒ± analiz et:
        {convo}
        Son mesaj: {text}
        - ≈û√ºbh…ôli varlƒ±qlar: {', '.join(context['suspicious_entities'])}
        - T…ôciliyy…ôt: {context['time_pressure']}
        - S…ôlahiyy…ôt iddiasƒ±: {context['authority_claim']}
        Cavabƒ± qƒ±sa v…ô ba≈üa d√º≈ü√ºl…ôn et.
        """
        return model.generate_content(prompt).text

# ----------------------
# Real-time voice input
# ----------------------
def main():
    required = ["AZURE_SPEECH_KEY", "AZURE_SPEECH_REGION", "AZURE_LANGUAGE_KEY", "AZURE_LANGUAGE_ENDPOINT", "GOOGLE_API_KEY"]
    if not all(os.getenv(k) for k in required):
        print("‚ö†Ô∏è ∆ètraf m√ºhit d…ôyi≈ü…ônl…ôri tapƒ±lmadƒ±!")
        return

    speech_config = speechsdk.SpeechConfig(subscription=os.getenv("AZURE_SPEECH_KEY"), region=os.getenv("AZURE_SPEECH_REGION"))
    speech_config.speech_recognition_language = "az-AZ"
    audio_config = speechsdk.audio.AudioConfig(use_default_microphone=True)
    recognizer = speechsdk.SpeechRecognizer(speech_config=speech_config, audio_config=audio_config)

    analyzer = ScamAnalyzer()
    print("üé§ Dinl…ôyir…ôm... (Dayandƒ±rmaq √º√ß√ºn Ctrl+C v…ô ya Enter)")

    def handle_result(evt):
        text = evt.result.text.strip()
        if len(text.split()) < 3:
            return
        print(f"\nüìù Tanƒ±nan m…ôtn: {text}")
        result = analyzer.analyze_text(text)
        if result:
            print("Scam Score:", result['scam_score'])

    def handle_canceled(evt):
        print(f"‚ùå Tanƒ±ma l…ôƒüv edildi: {evt.result.reason}")

    recognizer.recognized.connect(handle_result)
    recognizer.canceled.connect(handle_canceled)
    recognizer.start_continuous_recognition()

    try:
        input("\nEnter basƒ±n proqramƒ± dayandƒ±rmaq √º√ß√ºn...\n")
    except KeyboardInterrupt:
        pass
    recognizer.stop_continuous_recognition()
    print("üîö Proqram dayandƒ±rƒ±ldƒ±")

if __name__ == "__main__":
    main()